#include <stdio.h>

#define MAX 100

char stack[MAX];
int top = -1;

void push(char c) {
    if (top < MAX - 1) {
        stack[++top] = c;
    }
}

char pop() {
    if (top >= 0) {
        return stack[top--];
    }
    return '\0';
}

int str_len(char str[]) {
    int i = 0;
    while (str[i] != '\0') i++;
    return i;
}

void shiftReduceParser(char input[]) {
    int i = 0;
    int length = str_len(input);

    printf("Input: %s\n", input);
    while (i < length) {
        // Display current stack and remaining input
        printf("Stack: ");
        for (int j = 0; j <= top; j++) printf("%c", stack[j]);
        printf(", Input: ");
        for (int j = i; j < length; j++) printf("%c", input[j]);
        printf("\n");

        // Shift
        push(input[i]);
        i++;

        // Reduce aSb -> S
        if (top >= 2 && stack[top] == 'b' && stack[top - 1] == 'S' && stack[top - 2] == 'a') {
            pop(); pop(); pop(); push('S');
            printf("Reduced to S\n");
        }

        // Reduce ab -> S (base case)
        if (top >= 1 && stack[top] == 'b' && stack[top - 1] == 'a') {
            pop(); pop(); push('S');
            printf("Reduced to S (base case)\n");
        }
    }

    // Final Stack
    printf("Stack: ");
    for (int j = 0; j <= top; j++) printf("%c", stack[j]);
    printf("\n");

    if (top == 0 && stack[top] == 'S')
        printf("Input string is accepted (parsed successfully).\n");
    else
        printf("Input string is rejected.\n");
}

int main() {
    char input[MAX];
    printf("Enter a string to parse (only 'a' and 'b' allowed): ");
    scanf("%s", input);
    shiftReduceParser(input);
    return 0;
}


Sure! For the shift-reduce parser that reduces:

ab → S (base case)

aSb → S (recursive case)

You can try the following sample strings that should be accepted:

✅ Accepted Strings:
ab
→ ab → S

aabbb
→ ab → S, then aSb → S

aaabbbb
→ ab → S → aSb → S → aSb → S

aababb
→ ab → S, ab → S, aSb → S

❌ Rejected Strings (invalid grammar):
aab
→ No valid reduction to single S

abb
→ ab → S, leftover b remains

baab
→ Starts with b, no rule for that


Parsing, also known as syntactic analysis, is the process of analyzing a sequence of tokens to determine the grammatical structure of a program. It takes the stream of tokens, which are generated by a lexical analyzer or tokenizer, and organizes them into a parse tree or syntax tree.

The parse tree visually represents how the tokens fit together according to the rules of the language’s syntax. This tree structure is crucial for understanding the program’s structure and helps in the next stages of processing, such as code generation or execution. Additionally, parsing ensures that the sequence of tokens follows the syntactic rules of the programming language, making the program valid and ready for further analysis or execution.

What is the Role of Parser?
A parser performs syntactic and semantic analysis of source code, converting it into an intermediate representation while detecting and handling errors.

Context-free syntax analysis: The parser checks if the structure of the code follows the basic rules of the programming language (like grammar rules). It looks at how words and symbols are arranged.
Guides context-sensitive analysis: It helps with deeper checks that depend on the meaning of the code, like making sure variables are used correctly. For example, it ensures that a variable used in a mathematical operation, like x + 2, is a number and not text.
Constructs an intermediate representation: The parser creates a simpler version of your code that’s easier for the computer to understand and work with.
Produces meaningful error messages: If there’s something wrong in your code, the parser tries to explain the problem clearly so you can fix it.
Attempts error correction: Sometimes, the parser tries to fix small mistakes in your code so it can keep working without breaking completely.

Types of Parsing
The parsing is divided into two types, which are as follows:

Top-Down Parsing
Top-down parsing is a method of building a parse tree from the start symbol (root) down to the leaves (end symbols). The parser begins with the highest-level rule and works its way down, trying to match the input string step by step.

Bottom-Up Parsing
Bottom-up parsing is a method of building a parse tree starting from the leaf nodes (the input symbols) and working towards the root node (the start symbol). The goal is to reduce the input string step by step until we reach the start symbol, which represents the entire language.