# DGIM Algorithm - Count 1s in the Last N Bits of a Stream
# ---------------------------------------------------------
# This algorithm efficiently estimates the number of 1s in the last N bits of a stream
# using only O(log^2 N) space instead of storing all N bits.
# It works by grouping bits into exponentially increasing "buckets".
# Each bucket stores (timestamp_of_most_recent_1, size_of_bucket).

from collections import deque

class DGIM:
    def __init__(self, window_size):
        self.window_size = window_size       # N: sliding window size
        self.buckets = deque()                # holds (timestamp, bucket_size)
        self.timestamp = 0                    # global counter of bits seen

    def _expire_old_buckets(self):
        """Remove buckets that are older than the current window."""
        while self.buckets and self.buckets[0][0] <= self.timestamp - self.window_size:
            self.buckets.popleft()

    def _compress_buckets(self):
        """Ensure at most 2 buckets of each size are kept."""
        count_by_size = {}
        for i in range(len(self.buckets) - 1, -1, -1):
            ts, size = self.buckets[i]
            count_by_size[size] = count_by_size.get(size, 0) + 1
            if count_by_size[size] > 2:
                # merge two oldest buckets of same size
                old_ts, old_size = self.buckets[i + 1]
                self.buckets.remove((old_ts, old_size))
                self.buckets[i] = (ts, size * 2)
                break

    def add_bit(self, bit):
        """Process incoming bit in the stream."""
        self.timestamp += 1
        if bit == 1:
            # New bucket for this '1'
            self.buckets.append((self.timestamp, 1))
            self._compress_buckets()
        self._expire_old_buckets()

    def query(self):
        """Estimate number of 1s in the last N bits."""
        total = 0
        last_bucket_size = 0
        for i, (ts, size) in enumerate(reversed(self.buckets)):
            if i == 0:
                total += size
                last_bucket_size = size
            elif ts > self.timestamp - self.window_size:
                total += size
            else:
                # partially count the last (oldest) bucket
                total += size // 2
                break
        return total


# ---------------- SAMPLE USAGE ----------------
if __name__ == "__main__":
    stream = [1, 0, 1, 1, 0, 1, 0, 1, 1]  # sample input stream of bits
    dgim = DGIM(window_size=5)            # sliding window of last 5 bits

    for bit in stream:
        dgim.add_bit(bit)
        print(f"After adding {bit}: estimated 1s in last 5 bits = {dgim.query()}")